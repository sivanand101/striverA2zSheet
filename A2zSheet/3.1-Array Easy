4) Remove duplicates from array :



5)  Left rotate by one place . 

Firse element goes to last, and all other move to left. 
So store first element and loop with a[i-1] = a[i]

6) Left rotate by D places. 

0.....D.....n-1

1 2 3 4 5 6 , D=3 -> 4 5 6 1 2 3

If we see array after D, last element gets closer to first part and first element gets away. So reverse that part.
-> 1 2 3 6 5 4

Now first element of first part comes closer to 2nd part and last element goes away. So reverse that part.
-> 3 2 1 6 5 4

Now we can see our ans is reverse of this. So reverse. 
-> 4 5 6 1 2 3

So, reverse (0,D) + reverse (D,n) + reverse(0,n)

7) Move zeros to end without changing order of other elements. 

1 0 2 0 0 3 0 -> 1 2 3 0 0 0

We need all nonzeros on left and zeros on right.
If there were all 0s, then start of this set of zeros is -1.
So as we move from left to right, an increasing count from -1 denotes an additional nonzero element. So after this count, there should be all zeros.
So we can loop through the array normally and keep a pointer on left most side. 
And if loop variable is non-zero we will swap the element pointed by counter and loop variable. 
j = -1
for i=0 ; until i<n :
    if a[i] != 0 :
        j = j+1
    swap(a[i],a[j]) // for initial non-zeros, then it will swap with itself. 

8) union of non-decreasing arrays .

merge + until continuous elements are occuring, we will keep increasing pointer.

10) One element appear once. Others twice .

XOR. 

11) Longest subarray with given sum with only +ve elements .

sliding window. 

left=0,right=0.


until sum < K :  sum = sum + element at right, right++

when sum == K, len = max(len, right-left+1)

until sum > K,  sum = sum - element at left, left++ 

12) Longest subarray with given sum with +ve and -ve elements. 

sliding window wont work here bcz --=+, can increase sum while decreasing. 



